#!/usr/bin/env python

from twisted.internet import gtk3reactor, protocol
from twisted.internet.protocol import Protocol, ClientCreator
import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, Gdk, Gio, GObject, Pango
from funky import *
from struct import unpack
from os import environ
from os.path import join
import traceback

reactor = gtk3reactor.install()

class CmdEntry(Gtk.Entry):
	__gsignals__ = {
		'send': (GObject.SIGNAL_RUN_LAST, None, (str, )),
	}
	def send(self, s):
		self.emit('send', s)

	def __activate(self, _):
		s = self.get_text()
		self.set_text('')
		if len(s):
			self.send(s)

	def __init__(self):
		super(CmdEntry, self).__init__()
		self.connect('activate', self.__activate)

class ServerUI(Gtk.Box):
	__gsignals__ = {
		'server_cmd': (GObject.SIGNAL_RUN_LAST, None, (str, )),
	}
	def __setup_tags(self, buf):
		tag = buf.create_tag('font')
		tag.set_property('font', 'Lucida Console 8')

		tag = buf.create_tag('bold')
		tag.set_property('weight', Pango.Weight.BOLD)

		for x in ['red', 'blue', 'green',
				'cyan', 'magenta', 'yellow',
				'purple', 'black',
				'dark blue', 'dark green']:
			tag = buf.create_tag(x)
			tag.set_property('foreground', x)
			tag.set_property('foreground-set', True)

	def __cb(self, _, s):
		self.emit('server_cmd', s)

	def __init__(self):
		super(ServerUI, self).__init__(\
				orientation = Gtk.Orientation.VERTICAL,
				spacing = 6)

		self.entry = CmdEntry()
		self.entry.connect('send', self.__cb)

		self.text = Gtk.TextView()
		self.text.set_editable(False)
		self.text.set_cursor_visible(False)
		self.text.set_wrap_mode(Gtk.WrapMode.WORD)
		self.__setup_tags(self.text.get_buffer())
		scr = Gtk.ScrolledWindow()
		scr.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
		scr.add(self.text)

		scr.set_can_focus(False)
		self.text.set_can_focus(False)

		self.pack_start(Gtk.Label('Server Messages'), False, True, 0)
		self.pack_start(scr, True, True, 0)
		self.pack_start(self.entry, False, True, 0)

	def msg(self, msg, tags = []):
		tags.append('font')
		buf = self.text.get_buffer()
		i = buf.get_iter_at_offset(buf.get_char_count())
		buf.place_cursor(i)
		buf.insert_with_tags_by_name(i, msg, *tags)
		i = buf.get_iter_at_offset(buf.get_char_count())
		buf.place_cursor(i)

		if not '\n' in msg:
			return

		mark = buf.create_mark(None, i, left_gravity = True)
		self.text.scroll_to_mark(mark, 0.0, False, 0.0, 0.0)

	def on_rx_cmd(self, _, msg):
		self.msg('<<< ' + msg.cmd + '\n', ['bold'])

	def on_rx(self, _, msg):
		self.msg('<<< ' + str(msg) + '\n', ['dark green'])

	def on_tx(self, _, msg):
		self.msg('>>> ' + str(msg) + '\n', ['purple'])
		return

def encrypt(x):
	key = '$Revision: 1.183 $'
	x = client.LoginClientMsg(
		enctyp = 'XORP',
		enckey = key,
		nam = xorp(key, x.nam),
		pwd = xorp(key, x.pwd),
		client_type = xorp(key, x.client_type),
		client_id = xorp(key, x.client_id),
		jver = xorp(key, x.jver),
		osver = xorp(key, x.osver),
		client_ver = xorp(key, x.client_ver),
		mac = xorp(key, x.mac),
	)

	return x

class FunkProto(Protocol):
	def __init__(self, owner):
		self.owner = owner
		self.f = open('tx.log', 'w')

	def connectionMade(self):
		self.owner.conn_made(self)
	def dataReceived(self, data):
		self.owner.rx(data)
	def connectionLost(self, reason):
		self.owner.conn_lost(reason)

	def tx(self, d):
		b = d.get_bytes()
		self.f.write(b)
		self.f.flush()
		self.transport.write(b)

class FunkWindow(Gtk.Window):
	__gsignals__ = {
		'rx_msg': (GObject.SIGNAL_RUN_LAST, None, (object, )),
		'tx_msg': (GObject.SIGNAL_RUN_LAST, None, (object, )),
		'rx_cmd': (GObject.SIGNAL_RUN_LAST, None, (object, )),
		'tx_cmd': (GObject.SIGNAL_RUN_LAST, None, (object, )),
		'rx_ping': (GObject.SIGNAL_RUN_LAST, None, (object, )),
	}
	__disp = {
		server.PingServerMsg: 'rx_ping',
		server.CmdServerMsg: 'rx_cmd',
	}

	def on_rx_ping(self, _, msg):
		self.pong()

	def __init__(self):
		super(FunkWindow, self).__init__(type =
						Gtk.WindowType.TOPLEVEL)

		self.connect('rx_ping', self.on_rx_ping)
		self.connect('destroy', self.destroy)

		self.f = open('rx.log', 'w')
		self.__buf = ''
		self.__p = None
		self.__cr = ClientCreator(reactor, FunkProto, self)
		#self.__c = self.__cr.connectTCP('game.brettspielwelt.de', 7670)

		self.set_default_size(320, 280)
		hb = Gtk.HeaderBar()
		hb.set_show_close_button(True)
		hb.props.title = 'FunKlient'
		self.set_titlebar(hb)

		accel = Gtk.AccelGroup()
		accel.connect(Gdk.keyval_from_name('Q'),
				Gdk.ModifierType.CONTROL_MASK,
				0,
				self.destroy)
		accel.connect(Gdk.keyval_from_name('W'),
				Gdk.ModifierType.CONTROL_MASK,
				0,
				self.destroy)
		self.add_accel_group(accel)

		self.set_mnemonic_modifier(0)
		self.stack = Gtk.Stack()
		self.stack.set_transition_type(\
				Gtk.StackTransitionType.SLIDE_LEFT_RIGHT)
		self.stack.set_transition_duration(500)

		c = ServerUI()
		c.connect('server_cmd', self.server_cmd)
		self.connect('rx_msg', c.on_rx)
		self.connect('rx_cmd', c.on_rx_cmd)
		self.connect('tx_msg', c.on_tx)
		self.stack.add_titled(c, 'server', 'Server Messages')
		self.stack.child_set_property(c, 'icon-name',
					'accessories-dictionary-symbolic')

		vb = Gtk.Box(orientation = Gtk.Orientation.VERTICAL,
				spacing = 6)
		vb.pack_start(self.stack, True, True, 0)
		vb.pack_start(self.stack, True, True, 0)
		self.add(vb)

		stack_switcher = Gtk.StackSwitcher()
		stack_switcher.set_stack(self.stack)
		hb = Gtk.HeaderBar()
		hb.set_show_close_button(True)
		hb.props.title = 'FunKlient'
		hb.pack_end(stack_switcher)
		self.set_titlebar(hb)

	def game_cmd(self, s):
		def pass_cb(cmd, args):
			self.bid(-1, -1)

		def bid_cb(cmd, args):
			k, p = args.split(None, 2)
			self.bid(int(k), int(p))

		def rs_cb(cmd, args):
			k, o, m, ke = args.split(None, 3)
			self.buy_rs(int(k), int(o), int(m), int(ke))

		def build_cb(cmd, args):
			self.build(0, int(args))

		def nobuild_cb(cmd, args):
			self.build(1, 0)

		def fire_cb(cmd, args):
			a, b, c, d = args.split(None, 3)
			self.fire(int(a), int(b), int(c), int(d))

		def demolish_cb(cmd, args):
			self.demolish(0, int(args))

		def rsmove_cb(cmd, args):
			frm, to, rs = args.split(None, 2)
			self.rs_move(int(frm), int(to), int(cb))

		__disp = {
			'pass': pass_cb,
			'bid': bid_cb,
			'rs': rs_cb,
			'build': build_cb,
			'nobuild': nobuild_cb,
			'fire': fire_cb,
			'demolish': demolish_cb,
			'rsmove': rsmove_cb,
		}
		try:
			cmd, args = s.split(None, 1)
		except ValueError:
			cmd = s
			args = None
		cb = __disp.get(cmd, None)
		if cb is None:
			print 'GCMD', cmd, args
		else:
			cb(cmd, args)

	def server_cmd(self, _, s):
		if len(s) >=2 and s[:2] == '//':
			try:
				self.game_cmd(s[2:])
			except Exception, e:
				traceback.print_exc()
				pass
			return
		self.cmd(s);

	def first_init(self):
		x = client.InitClientMsg()
		self.tx(x)

	def login(self, nam, pwd):
		x = client.LoginClientMsg(
			nam = nam,
			pwd = pwd,
			osver = 'amd64-4.4.0-31-generic-Linux',
			mac = '1015660640995 MAC:201564d3cb780 /fe80:0:0:0:d0e5:adff:feba:8c0%lxcbr0/10.0.3.1- MAC:a434d9c551ca/fe80:0:0:0:a634:d9ff:fec5:51ca%wlp4s0/172.20.10.5'
	)
		x = encrypt(x)
		self.tx(x)

	def refresh(self):
		x = client.RefreshClientMsg()
		self.tx(x)

	def game_start(self):
		x = client.GameStartClientMsg()
		self.tx(x)

	def tool_init(self, tool):
		x = client.ToolClientMsg(tool = tool)
		self.tx(x)

	def pong(self):
		x = client.PingClientMsg()
		self.tx(x)

	def cmd(self, cmd):
		x = client.CmdClientMsg(cmd = cmd)
		self.tx(x)

	def demolish(self, plant):
		self.action(0, plant, 0, 0, 0)

	def fire(self, a, b, c, d):
		self.action(0, a, b, c, d)

	def buy_rs(self, coal, oil, trash, nuke):
		self.action(0, coal, oil, trash, nuke)

	def rs_move(self, frm, to, rs):
		self.action(2, frm, to, rs, 0)

	def build(self, act, s):
		self.action(act, s, 0, 0, 0)

	def bid(self, k, p):
		if k < 0:
			k = 0x3f
		if p < 0:
			p = 0x3f
		code = (p << 6) | k
		x = client.FunkenClientMsg(code = code)
		self.tx(x)

	def action(self, act, k, p, p1, p2):
		code = (act << 28)
		code |= k
		code |= p << 6
		code |= p1 << 12
		code |= p2 << 18
		x = client.FunkenClientMsg(code = code)
		self.tx(x)

	def conn_made(self, p):
		login = open(join(environ['HOME'], '.bsw-account')).read()
		nam, pwd = login.rstrip('\r\n').split(':', 1)

		self.__p = p
		self.first_init()
		self.login(nam, pwd)
		self.refresh()
		self.game_start()
		self.refresh()
		for x in ('BackTool', 'LobbyTool', 'UserGameTool',
				'GatherTool', 'TrennTool', 'NewsTool',
				'UserInfoTool', 'UserListTool', 'ChannelTool',
				'HelpTool', 'ArbeitsplatzTool', 'LastGameTool',
				'RemoteCmdTool'):
			self.tool_init(x)

	def conn_lost(self, reason):
		print 'conn_lost', reason
		self.__p = None

	def rx_msg(self, t, b):
		c = server.msgmap.get(t, None)
		if c is None:
			#print 'UNKNOWN(%r), %r'%(t, b)
			return

		x = c.frombytes(b)

		self.emit('rx_msg', x)

		sig = self.__disp.get(c, None)
		if sig is None:
			return

		self.emit(sig, x)

	def rx(self, data):
		self.f.write(data)
		self.f.flush()
		self.__buf += data
		while len(self.__buf) >= 5:
			(hi, lo, t) = unpack('>BHH', self.__buf[:5])
			l = (hi << 16) | lo
			assert(l >= 5)
			if l > len(self.__buf):
				break
			b = self.__buf[5:l]
			self.__buf = self.__buf[l:]
			self.rx_msg(t, b)

	def tx(self, d):
		if self.__p is None:
			print 'NOT SENT', d
			return
		self.emit('tx_msg', d)
		self.__p.tx(d)

	def destroy(self, *_):
		super(FunkWindow, self).destroy()
		reactor.stop()

class FunKlient(Gtk.Application):
	def __init__(self):
		super(FunKlient, self).__init__(
				application_id = 'apps.fun.klient',
				flags = Gio.ApplicationFlags.FLAGS_NONE)
		self.connect('activate', self.on_activate)

	def on_activate(self, data = None):
		window = FunkWindow()
		window.show_all()
		self.add_window(window)


def main():
	app = FunKlient()
	reactor.registerGApplication(app)
	reactor.run()

if __name__ == '__main__':
	main()
